// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

////////////////////////////////////////////////////
// AUTOGENERATED - DO NOT EDIT THIS FILE DIRECTLY //
////////////////////////////////////////////////////

import "forge-std/Script.sol";

import "src/Vault.sol";
import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import {TransparentUpgradeableProxy, ITransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

abstract contract VaultDeployer is Script {
    Vault internal vault;
    ProxyAdmin internal vaultProxyAdmin;
    address internal vaultImplementation;

    function deployVault() internal returns (address) {
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        bytes memory bytecode = vm.readFileBinary("test/bin/permit2.bytecode");
        address permit2_;
        assembly {
            permit2_ := create(0, add(bytecode, 0x20), mload(bytecode))
        }
        vm.stopBroadcast();
        address usdc = 0x94a9D9AC8a22534E3FaCa9F4e7F2E2cf85d5E4C8;
        address tcapV2 = vm.getDeployment("TCAPV2");
        return deployVaultImplementation(ITCAPV2(tcapV2), IERC20(usdc), IPermit2(permit2_));
    }

    function deployVaultTransparent(
        address proxyAdminOwner,
        ITCAPV2 tCAPV2_,
        IERC20 collateral_,
        IPermit2 permit2_,
        address admin,
        uint16 initialFee,
        address oracle_,
        address feeRecipient_,
        IVault.LiquidationParams memory liquidationParams_
    ) internal returns (address implementation, address proxyAdmin, address proxy) {
        bytes memory initData = abi.encodeCall(Vault.initialize, (admin, initialFee, oracle_, feeRecipient_, liquidationParams_));

        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        vaultImplementation = address(new Vault(tCAPV2_, collateral_, permit2_));
        vault = Vault(address(new TransparentUpgradeableProxy(vaultImplementation, proxyAdminOwner, initData)));

        vm.stopBroadcast();

        vaultProxyAdmin = ProxyAdmin(address(uint160(uint256(vm.load(address(vault), hex"b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103")))));

        return (vaultImplementation, address(vaultProxyAdmin), address(vault));
    }

    function deployVaultImplementation(ITCAPV2 tCAPV2_, IERC20 collateral_, IPermit2 permit2_) internal returns (address implementation) {
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        implementation = address(new Vault(tCAPV2_, collateral_, permit2_));
        address admin = vm.addr(vm.envUint("PRIVATE_KEY"));
        address usdcOracle = vm.getDeployment("AggregatedChainlinkOracle");
        IVault.LiquidationParams memory liquidationParams = IVault.LiquidationParams({threshold: 1e18, penalty: 0, minHealthFactor: 1, maxHealthFactor: 1e18});
        Vault(implementation).initialize(
            admin,
            100,
            usdcOracle,
            admin,
            liquidationParams
        );
        vm.stopBroadcast();
    }
}
